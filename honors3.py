def findxy(a, b): #returns the x and y euclidean basecase if the numbers are coprime
                    #and a distinguishable case if they aren't coprime

    rem = a % b #calculates r for use in the next layer

    if rem == 0 and b == 1: #base case 1: remainder hits 0 AND the two numbers are coprime

        return (1, 1-a//b) #returns the base value that will be used in calculating the final value
                            #in the form of a tuple where [0] is x1 and [1] is y1 i.e. (x1, y1)
                                            # x1 and y1: from equations x = y1 and y = x1 - q*y1

    elif rem == 0 and b != 1: #base case 2: remainder hits 0 AND the two numbers are not coprime

        return (0, 0) #returns this which allows for easy identification later in findxyifcoprime(a, b)

    xy = findxy(b, rem) #recursively calls the function on the b and rem of this layer
                        #calculates a new rem using the old rem that's tested again

    return (xy[1], xy[0] - a//b * xy[1]) #returns the final (x,y) value by plugging the basecase into the recursive function generated by findxy(a, b)
                                            #in the not coprime case, this will ALWAYS return (0,0) which the coprime case will NEVER return

def findxyifcoprime(a, b): #a shell for findxy(a, b) that differs its output based on whether a and b are coprime

    if findxy(a, b) == (0, 0): #this is the non-coprime case from findxy(a, b)

        return "numbers aren't coprime" #ends function and notifies user of non-coprime numbers

    else:

        return findxy(a, b) #simply returns what the result of findxy(a, b) is

#some tests
print(findxyifcoprime(11, 9)) #expect (5, -6)
print(findxyifcoprime(6, 12)) #expect "numbers aren't coprime"
print(findxyifcoprime(15, 23)) #expect (20, -13)

print(findxyifcoprime(26, 77))
print(findxyifcoprime(180, 150))
print(findxyifcoprime(30967, 32399))
print(findxyifcoprime(400, 179))